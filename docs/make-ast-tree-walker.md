@textlintDocumentExit.md @TstAST_interface.md  のガイドにおいて、textlint rule内で状態を保持できること、ツリー構造状のデータモデルの2点がわかった。 @module.ts では現在、条件に適合するテキストを取得しようとしているが、単一のnodeに相当するものしか閲覧できない呼び出し側の制約のために断念していた。しかし状態を保持できるのであれば別だ。呼び出し時点でのASTも、コメントに限定することでより合理的な挙動が望める。そもそもASTに従うことで、 module.ts側で行っていた一部の条件分岐も必要になり、全体が簡素になる。これを前提に @index.ts と、 @conditional-disable-validate-directive.ts の現在の状態モデルと、その修正を想定し、どのような修正が必要になるか検証せよ。

なお、現在の探索アルゴリズムは無限ループに陥ることがわかっている。調査を通じてその原因究明もサブタスクとして実行し、調査が十分かどうかはこのバグの原因分析の明確さによって確認することとしよう。ただし、これは主要目標ではないことに気をつけてください。

方針は既に固まっている。オフィシャルのドキュメントをレビューした結果、必要なものはツリーウォーカーのアルゴリズムであると言うことが判明した。ここで重要な事は2つある。まず第一に全体のツリーを一旦保存しておくこと。そして次にすべてのコメントにおいて処理を開始すること、ノードの種類によってハンドラーを設定できる機能があるのでそれを利用すると良さそうだ。今回重要になるアルゴリズムは今回のデータモデルにおいて深さ方向ではなく、幅の方向に重要である。すべてのコメントにおいて、その次の兄弟を取得すると言う処理が問題の本質である。あるコメントが条件を満たしているときに、その次の兄弟がどのような条件を満たしているのかを判定することが大事だ。これにはまずスキップするべき種類と受け入れるべき種類があって、例えば当然のことながら、パラグラフ要素は必ず処理するべきだ しかし、1部のエレメントは目的のものとそうでないものが混在している可能性がある。そのような場合は、今回の条件を判定するために、十分に純粋であると思われるような要素を子孫方向にたどって取得すると言うことになる すなわち要素の種類は4種類ある。まず第一にコメントである。その次にディレクティブの対象となるべき中身のあるコンテンツである。そして第3に 改行要素など中身の存在しないコンテンツである。第4にこれらが混在したコンテナとでも言うべき要素である。この4つを明確に分類していくことができれば、今回のアルゴリズムは明快にシンプルに実装することができる。ここで重要なポイントは、我々はドキュメントにも説明のある通り、コメント要素が来たときだけコールされる。関数をセットする。もしコメント要素が来たら、その時点からツリーウォーカーのアルゴリズムを起動させるツリーウォーカーは、受け取ったコメントノードを出発地点として、ターゲットとなるべき中身のあるコンテンツにたどり着くまでデータの中を移動する。

ツリーウォーカーをシンプルに考えることから開始しよう。ドキュメントノードをセットし、parent, child, siblingの3方向に移動できる、ミニマムなつくりのものを考えよう。それとは別に、判定ユーティリティを関数で作成しよう。4種類のノードタイプはTypeScriptのstring unionや、それに依存する構造型として独自に定義しよう。すでに公式が用意してくれているノードタイプの型システムは判定ロジックの際に使用して頑健にしよう。コントロールは完全に外部化して、走査的に扱うための小さなデータモデルと、単一の関数を起点とする判定ロジックを頑健に作ろう。まずはそこまでやりましょう。コントロールは実現できてなくていいです。むしろ全体を統合して機能を実現するコントロール部分は積極的に作業スコープ外とすることで、頑健でシンプルなシステムにつながると思う。

それでは、状態モデルの分析と新しいシンプルな状態モデルの設計を開始するためのドキュメントを詳細にしてください。評価基準は実装のシンプルさと頑健さです。